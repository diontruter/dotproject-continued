<?php  // $Id$
class Cinstall {

//  @var bool Did we create the db successfully?
var $dbConfigured = false;

//  @var bool Did we create the db successfully?
var $dbCreated = false;

//  @var bool Did we populate the db successfully?
var $dbPopulated = false;

//  @var bool Did we create the cfg file successfully?
var $cfgFileCreated = false;

//  @var bool Is config.php writable?
var $cfgFileWritable = false;

//  @var array Dynamic Container for array keys of booleans in config array
var $boolcfg = array();

//  @var array Dynamic Container for config data
var $cfg = array();

//  @var array List of available ADODB db drivers
var $dbDrivers = array();

//  @var array Persistent Container for original configuration data
var $dPcfg = array();

//  @var array Container for various informations needed in install process
var $various = array();

//	@var Object permissions container for providing dummy permissions with installer
var $_acl = null;

	// Constructor: populate config arrays
	function Cinstall() {

                if ($GLOBALS["dPrunLevel"] == 0) {             // config.php is not available, nor $dPconfig

                        /* we load config values from config-dist.php
                        ** and override some wrong values with guessed information.
                        ** We also have to set $dPconfig.
                        */

                        // initialize class config array
                        $this->cfg = $this->getCfgFile();

                        // register config vars of boolean type
                        $this->registerBools();

                        // keep a copy of original config data here
                        $this->dPcfg = $this->cfg;

                        // guess and override some run critical cfg values
                        $this->guessImportantCfg();

                        // initialize global config values
                        $this->updateDPcfg( $this->cfg );

                } else {                                        // config.php available, hence we have $dPconfig

                        // we load config values from config.php
                        $this->dPcfg = $this->cfg = $GLOBALS["dPconfig"];

                        // config.php is already there
                        $this->cfgFileCreated = true;

                        // DB is there if dPrunLevel > 0
                        if ($GLOBALS["dPrunLevel"] > 1) {
                                $this->dbCreated = true;
                        }
                // override the host style (only the default style is tweaked to run without database)
                $GLOBALS["dPconfig"]['host_style'] = "default";

                }

		// discover and determine writability of config.php
		$this->cfgFileWritable = $this->isCfgFileWritable();

                // create a list of available database Driver Names
                $this->dbDrivers = array ( "access" => "access", "ado"=> "ado", "ado_access"=> "ado_access", "ado_mssql"=> "ado_mssql",
                                "db2" => "db2", "vfp" => "vfp", "fbsql" => "fbsql", "ibase" =>"ibase", "firebird" => "firebird",
                                "borland_ibase" => "borland_ibase", "informix" => "informix", "informix72" => "informix72",
                                "ldap" => "ldap", "mssql" =>"mssql", "mssqlpro" =>"mssqlpro", "mysql" => "mysql", "mysqlt" => "mysqlt",
                                "maxsql" => "maxsql", "oci8" => "oci8", "oci805" => "oci805", "oci8po" => "oci8po", "odbc" => "odbc",
                                "odbc_mssql" => "odbc_mssql", "odbc_oracle" => "odbc_oracle", "odbt" => "odbt", "odbt_unicode" => "odbt_unicode",
                                "oracle" => "oracle", "netezza" => "netezza", "postgres" => "postgres", "postgres64" => "postgres64",
                                "postgres7" => "postgres7", "sapdb" => "sapdb", "sqlanywhere" => "sqlanywhere", "sqlite" => "sqlite",
                                "sqlitepo" => "sqlitepo", "sybase" => "sybase" );

	}

        /*
        * Prepare Config Values from config array for File Output
        * @return $config string Code output for dP-like config file
        */
	function cfgFilePrepare() {
                $config = "<?php \n";
		$config .= "### Copyright (c) 2004, The dotProject Development Team dotproject.net and sf.net/projects/dotproject ###\n";
		$config .= "### All rights reserved. Released under BSD License. For further Information see ./includes/config-dist.php ###\n";
		$config .= "\n";
		$config .= "### CONFIGURATION FILE AUTOMATICALLY GENERATED BY THE DOTPROJECT INSTALLER ###\n";
		$config .= "### FOR INFORMATION ON MANUAL CONFIGURATION AND FOR DOCUMENTATION SEE ./includes/config-dist.php ###\n";
		$config .= "\n";
		$keys = array_keys($this->cfg);
		foreach ($keys as $k) {
                        // convert empty booleans to false (vars for unchecked checkboxes are empty)
                        if ( in_array( "$k", $this->boolcfg ) ) {
                                if ($this->cfg["$k"] > null) {
                                         $config .= "\$dPconfig['{$k}'] = true;\n";
                                }
                                else {
                                         $config .= "\$dPconfig['{$k}'] = false;\n";
                                }
                        } else {
			        $config .= "\$dPconfig['{$k}'] = \"{$this->cfg["$k"]}\";\n";
                        }
		}
                $config .= "?>";

		return trim($config);

	}

        /*
        * write config data to config file, use therefore config parameter or values prepared by Cinstall::cfgFilePrepare()
        * @param $file string filename
        * @param $config array Config values to write
        * @return bool File written successfully?
        */
	function cfgFileStore( $file = "./includes/config.php", $config = null ) {
		if (empty($config)) {
			$config = $this->cfgFilePrepare();
		}

		if ($this->isCfgFileWritable($file) && ($fp = fopen($file, "w"))) {
			fputs( $fp, $config, strlen( $config ) );
			fclose( $fp );
			$this->cfgFileCreated = true;
		} else {
			$this->cfgFileWritable = false;
			$this->cfgFileCreated = false;
		}
		return $this->cfgFileCreated;
	}

        /*
        * check if config file is writable
        * @return bool
        */
	function isCfgFileWritable( $file = "./includes/config.php" ) {
		return is_writable($file);
	}

         /*
        * discover and save of boolean values in config array
        */
        function registerBools() {
		$keys = array_keys($this->cfg);
		foreach ($keys as $k) {
                        if (is_bool($this->cfg["$k"]))  {
                                $this->boolcfg[] = "$k";
                        }
		}
	}

        /*
        * bind post data to various infos array necessary to be transported by post and stored in session data
        * @param $data array Array of postdata (of the form various[key])
        */
	function bindToVarious( $data = array() ) {
		$keys = array_keys($data);
		foreach ($keys as $k) {
			$this->various["$k"] = trim($data["$k"]);
		}
	}

        /*
        * bind post data to config array
        * @param $data array Array of postdata (of the form pd[key])
        */
	function bindPost( $data = array() ) {
                // get array keys for boolean config vars
                $bc = $this->boolcfg;
		$keys = array_keys($data);
		foreach ($keys as $k) {
			$this->cfg["$k"] = trim($data["$k"]);
		}
                // create a list of unsent boolean config vars (estimated to be false)
                $bn = array_unique(array_diff($bc, $keys));
                // set unsent/false config data to null
                foreach ($bn as $bk) {
                        $this->cfg["$bk"] = null;
                }
	}

        /*
        * read existing config data from config file
        * @param $file string filename
        * @return $dPconfig array Config array
        */
	function getCfgFile( $file = "./includes/config-dist.php" ) {

		is_file( $file )
		or die("$file is not available. It is needed for guessing some config values for installation procedure.
		Therefore you should never delete or modify it.Please restore this file.");

		// include the standard config values
		include_once( $file );

		return $dPconfig;
	}

	function updateDPcfg ( $data = array() ) {
		global $dPconfig;
		$dPconfig = array_merge($dPconfig, $data);
	}

	function updateDPcfgFromPost ( $data = array() ) {
		global $dPconfig;
		$keys = array_keys($data);
		foreach ($keys as $k) {
			$dPconfig["$k"] = trim($data["$k"]);
		}
	}

        /*
        * override some possibly wrong mission critical config values
        */
	function guessImportantCfg() {
		//$this->cfg['root_dir'] = realpath("./");
		//$this->cfg['base_url'] = "http://".$_SERVER["SERVER_NAME"].str_replace("/index.php", "", $_SERVER["PHP_SELF"]);
	}

        /*
        * check if adodb connection is up
        * @return bool
        */
	function isADODBconnected() {
		global $db;
		return (is_object($db));
	}

        /*
        * check if adodb database connection and selection is up
        * @return bool
        */
	function isDBconnected() {
		global $dbc;
		return $dbc;
	}

        /*
        * encapsulate adodb connection
        * @return bool
        */
	function ADODBconnect( $dbtype = null ) {
		global $db;
		$dPconfig['dbtype'] = empty($dbtype) ? $dbtype : $this->cfg['dbtype'];
		include_once("./includes/db_adodb.php");
		return $db;
	}

        /*
        * encapsulate adodb database selection and connection
        * @return bool
        */
	function DBconnect() {
		global $db, $dbc;
		if(!empty($db)) {
			if ($this->cfg['persist']) {
				$dbc = $db->PConnect($this->cfg['dbost'],$this->cfg['dbuser'],$this->cfg['dbpass'],$this->cfg['dbname']);
			} else {
				$dbc = $db->Connect($this->cfg['dbost'],$this->cfg['dbuser'],$this->cfg['dbpass'],$this->cfg['dbname']);
			}
		} else { $dbc = false; }
		return $dbc;
	}

        /*
        * creates a database
        * @return bool
        */
	function createDB( $dbname = null ) {
		$dbname = !empty($dbname) ? $dbname : $this->cfg['dbname'];
		return db_exec("CREATE DATABASE ".$dbname);
	}

        /*
        * poulates the database with SQL from file
        * @param $sqlfile string Filename
        * @return bool
        */
	function populateDB($sqlfile = "./db/dotproject.sql") {
		if( !$this->isDBconnected() ) {
			return false;
		}
		$mqr = @get_magic_quotes_runtime();
		@set_magic_quotes_runtime(0);
		$query = fread(fopen($sqlfile, "r"), filesize($sqlfile));
		@set_magic_quotes_runtime($mqr);
		$pieces  = $this->splitSql($query);
		$errors = array();
		for ($i=0; $i<count($pieces); $i++) {
			$pieces[$i] = trim($pieces[$i]);
			if(!empty($pieces[$i]) && $pieces[$i] != "#") {
				if (!$result = db_exec($pieces[$i])) {
					$errors[] = array ( db_error(), $pieces[$i] );
				}
			}
		}
		return true;
	}

        /*
        * Utility function to split given SQL-Code
        * @param $sql string SQL-Code
        */
	function splitSql($sql) {
		$sql = trim($sql);
		$sql = ereg_replace("\n#[^\n]*\n", "\n", $sql);

		$buffer = array();
		$ret = array();
		$in_string = false;

		for($i=0; $i<strlen($sql)-1; $i++) {
			if($sql[$i] == ";" && !$in_string) {
				$ret[] = substr($sql, 0, $i);
				$sql = substr($sql, $i + 1);
				$i = 0;
			}

			if($in_string && ($sql[$i] == $in_string) && $buffer[1] != "\\") {
				$in_string = false;
			}
			elseif(!$in_string && ($sql[$i] == '"' || $sql[$i] == "'") && (!isset($buffer[0]) || $buffer[0] != "\\")) {
				$in_string = $sql[$i];
			}
			if(isset($buffer[1])) {
				$buffer[0] = $buffer[1];
			}
			$buffer[1] = $sql[$i];
		}

		if(!empty($sql)) {
			$ret[] = $sql;
		}
		return($ret);
	}

         /*
        * Generate ADODB-XML-Schema-File with Structure and Content from Database
        * @param $content bool sets whether structure and content (true) should be exported or only structure (false)
        */
	function generateBackupSchema( $content = true ) {
                global $db, $dbc;
                if( !$this->isDBconnected() ) {
			return false;

		} else {

			require_once( "{$this->cfg['root_dir']}/lib/adodb/adodb-xmlschema.inc.php" );

			$schema = new adoSchema( $db );

			$sql = $schema->ExtractSchema($content);

			header('Content-Disposition: attachment; filename="dPdbBackup'.date("Ymd").date("His").'.xml"');
			header('Content-Type: text/xml');
			echo $sql;

			return true;
		}
        }

	  /*
        * apply an ADODB-XML-Schema-File to the Database
        * @param $file string ADODB-XML-Schema-Filepath
        */
	function applyBackupSchema( $file ) {
                global $db, $dbc;
                if( !$this->isDBconnected() ) {
			return false;

		} else {

			require_once( "{$this->cfg['root_dir']}/lib/adodb/adodb-xmlschema.inc.php" );

			$schema = new adoSchema( $db );
			$schema->ParseSchemaFile( $file );
			$schema->ExecuteSchema();

			return true;
		}
        }

	function & acl() {
		if (! isset($this->_acl))
			$this->_acl =& new InstallerPermissions;
		return $this->_acl;
	}

}

class InstallerPermissions {
	function checkModule($modname, $method, $user_id = null) {
		return true;
	}
}
?>
